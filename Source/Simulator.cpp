//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : Simulator.cpp
//  @ Date : 5/20/2013
//  @ Author : 
//
//


#include "../Headers/Simulator.h"

Simulator::Simulator(SetOfAssemblyTiles S, QMap<QString, int> &StrengthFunction, int Theta, int StepNumber)
/*
 Post-Condition: Simulator with initial set of tiles S, strength map, theta parameter, and # of steps is created
 */
    : manager(S), StrengthMap(StrengthFunction), ThetaParameter(Theta), NumberOfSteps(StepNumber)
{

}

void Simulator::initialize()
/*
 Post-Condition: All initialization goes here
 */
{
    currentStep = 1;
}

void Simulator::startSimulation()
/*
 Main function that starts simulation
 */
{
    for(currentStep; currentStep <= NumberOfSteps; currentStep++)   //Perform simulation, until the number of required steps is reached
    {
        SetOfAssemblyTiles newSet;  //New empty set of Assembly tiles
        SetOfAssemblyTiles currentSet = selectMostCurrentSetOfAssemblyTiles();  //most up to date set of assembly tiles
        QList<AssemblyTile>::Iterator i;
        for(i = currentSet.getListOfAssemblyTiles().begin(); i!=currentSet.getListOfAssemblyTiles().end(); i++)
        {
            AssemblyTile t1 = *i;   //get next first assembly tile t1
            QList<SetOfAssemblyTiles>::Iterator j;
            for(j = manager.getListOfSets().begin(); j!=manager.getListOfSets().end(); j++)//iterate through every set of assembly tiles
            {
                SetOfAssemblyTiles temp = *j;   //get temporal set of assembly tiles for picking the second assembly tile
                QList<AssemblyTile>::Iterator k;
                for(k = temp.getListOfAssemblyTiles().begin(); k!=temp.getListOfAssemblyTiles().end(); k++)    //each tile in temp iterate through and try to combine two tiles
                {
                    AssemblyTile t2 = *k;  //chose second assembly tile
                    if(&temp == &currentSet && t2.getIndex() < t1.getIndex()) //check for redundant tiles
                    {
                        continue;
                    }
                    QList<FitPlace*> *spots;
                    spots = findFittingSpots(t1, t2);   //get all fitting spots
                    if(spots == 0)   //check if there are any fitting spot
                    {
                        continue;
                    }
                    QList<FitPlace*>::Iterator fit;
                    for(fit = spots->begin(); fit!=spots->end(); fit++)  //iterata through each fitting spot
                    {
                        FitPlace * next = *fit;   //get next spot
                        AssemblyTile* combined = attemptToCombine(t1, t2, next);
                        delete next;    //free the memory
                        if(combined == 0)   //check if tiles were combined
                        {
                            continue;
                        }

                        newSet.addAssemblyTile(*combined);
                    }

                    delete spots;   //free the memory
                }
            }

         }
        if(newSet.isEmpty())    //check if new set is empty
        {
            break;
        }
        manager.addSet(newSet);
    }

}

/*SetOfAssemblyTiles & Simulator::createNewSetOfAssemblyTiles()
/*
 Post-Condition: New empty set of assembly tiles is created and returned
 /
{

}*/
SetOfAssemblyTiles & Simulator::selectMostCurrentSetOfAssemblyTiles()
/*
 Post-Condition: Most updated set of assembly tiles is returned. This set contains tiles that will be picked as First Assembly Tiles
 */
{
    return manager.getAssemblyTileSet(currentStep - 1);
}

QList<FitPlace*> *Simulator::findFittingSpots(AssemblyTile &T1,AssemblyTile &T2)
/*
 Post-Condition: All possible fitting places of T1 and T2 are found and put in a list
 */
{
    QList<FitPlace*> *fitPlaces = new QList<FitPlace*>;
    foreach(freeActiveLabel label1, T1.getListOfFreeSides())
    {
        foreach(freeActiveLabel label2, T2.getListOfFreeSides())
        {
            if(label1.match(label2))
            {
                QPair<int, int> coord;
                switch(label1.side)
                {
                    case x: coord.first = label1.xyCoord.first + 1;
                            coord.second = label1.xyCoord.second;
                            break;

                    case y: coord.first = label1.xyCoord.first;
                            coord.second = label1.xyCoord.second + 1;
                            break;

                    case _x: coord.first = label1.xyCoord.first - 1;
                             coord.second = label1.xyCoord.second;
                             break;

                    case _y: coord.first = label1.xyCoord.first;
                             coord.second = label1.xyCoord.second - 1;
                             break;

                }
                int rotation = (label1.side - ((label2.side + 2)%4)) % 4;
                FitPlace *match = new FitPlace(coord, label2.xyCoord, rotation);
                fitPlaces->append(match);
            }
        }
    }

    return fitPlaces;
}

AssemblyTile * Simulator::attemptToCombine(AssemblyTile T1,AssemblyTile T2, FitPlace *place)
/*
 Post-Condition: T1 and T2 are attempted to be combined at places first and second. If successful, pointer to a new tile is returned.
 If not successful, NULL is returned
 */
{

}

bool Simulator::checkXYOverlap(AssemblyTile & T1, AssemblyTile & T2)
/*
 Post-Condition: Check if T1 and T2 contain an overlap of xy coordinates, i.e. do not fit each other.
 return true, if there is an overlap, and false otherwise
 */
{

}

bool Simulator::checkBondsStrength(AssemblyTile & T1, AssemblyTile & T2)
/*
 Post-Condition: Check if T1 and T2 can be combined satisfying bond strength condition.
 return true if they can, and false if they can't
 */
{

}

void Simulator::TileModificationFunction(AssemblyTile & T)
/*
 Post-Condition: Apply tile modification function to tile T
 */
{

}
