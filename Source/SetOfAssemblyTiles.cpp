//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : SetOfAssemblyTiles.cpp
//  @ Date : 5/20/2013
//  @ Author : 
//
//


#include "../Headers/SetOfAssemblyTiles.h"

#ifdef DEBUG
    int SetOfAssemblyTiles::ID = 0;   //unique id for everytile
#endif

SetOfAssemblyTiles::SetOfAssemblyTiles()
/*
 Default Constructor
 */
    :  numberOfAssemblyTiles(0), setID_StepNumber(-1)
{
#ifdef DEBUG
    this->uniqueID = SetOfAssemblyTiles::ID;
    SetOfAssemblyTiles::ID++;
#endif

}

SetOfAssemblyTiles::SetOfAssemblyTiles(AssemblyTile *A)
/*
 Post-Condition: Set of assembly Tiles is created with one assembly tile in it
 */
    :  numberOfAssemblyTiles(1), setID_StepNumber(-1)
{
#ifdef DEBUG
    this->uniqueID = SetOfAssemblyTiles::ID;
    SetOfAssemblyTiles::ID++;
#endif
    listOfAssemblyTiles.append(A);
    A->setIndex(0);
}

SetOfAssemblyTiles::SetOfAssemblyTiles(AssemblyTile *A[], int n)

/*
 Post-Condition: Set of assembly Tiles is created with n assembly tiles in it
 */
    : numberOfAssemblyTiles(n), setID_StepNumber(-1)
{
#ifdef DEBUG
    this->uniqueID = SetOfAssemblyTiles::ID;
    SetOfAssemblyTiles::ID++;
#endif
    for(int i = 0; i < n; i++)
    {
        listOfAssemblyTiles.append(A[i]);
        A[i]->setIndex(i);
    }
}

SetOfAssemblyTiles::~SetOfAssemblyTiles()
/*
 Default destructor
 */
{
    for(QList<AssemblyTile*>::iterator it = this->listOfAssemblyTiles.begin(); it != this->listOfAssemblyTiles.end(); ++it)
    {
        delete *it;
    }
}

void SetOfAssemblyTiles::addAssemblyTile(AssemblyTile * const T)
/*
 Post-Condition: If assembly tile is not in the set, then it is added to the set
 */
{
    if(listOfAssemblyTiles.isEmpty())   //first check if list is empty
    {
        T->setIndex(0); //if it is, then set index to 0
    }

    else if(this->contains(T))    //if list is not empty, then check if tile is already in the set
    {
        return; //if so, then return
    }


    else
    {
        T->setIndex(listOfAssemblyTiles.last()->getIndex() + 1);  //else assign next index to the tile
    }

    listOfAssemblyTiles.append(T);  //add it to the list
    numberOfAssemblyTiles++;    //increase # of tiles
    return;

}

void SetOfAssemblyTiles::removeAssemblyTile(AssemblyTile * const T)
/*
 Post-Condition: If assembly tile is in the set, then it is removed from the set
 */
{
    if(!(this->contains(T)))
    {
        return;
    }

    listOfAssemblyTiles.removeOne(T);
    numberOfAssemblyTiles--;
}

bool SetOfAssemblyTiles::checkIfTileIsInTheSet(const AssemblyTile * const T)const
/*
 Post-Condition: If T is in the set, then function returns true, and false otherwise
 */
{
    return this->contains(T);
}

AssemblyTile & SetOfAssemblyTiles::getAssemblyTile(int index)
/*
 Post-Condition: Return an assembly tile corresponding to the index
 */
{
    return *(listOfAssemblyTiles[index]);
}

QList<AssemblyTile *> &SetOfAssemblyTiles::getListOfAssemblyTiles()
/*
 Post-Condition: Returns list of all assembly tiles
 */
{
    return listOfAssemblyTiles;
}
int SetOfAssemblyTiles::getSetId() const
/*
 Post-Condition: Returns the id of current set, which corresponds to the step numberOfAssemblyTiles
 */
{
    return setID_StepNumber;
}

void SetOfAssemblyTiles::setID(int ind)
/*
 Post-Condition: Sets the id of current set, which corresponds to the step numberOfAssemblyTiles
 */
{
    setID_StepNumber = ind;
    return;
}

bool SetOfAssemblyTiles::isEmpty()const
/*
 Post-Condition: If set is empty, returns true, and false otherwise
 */
{
    return listOfAssemblyTiles.isEmpty();
}
bool SetOfAssemblyTiles::operator==(const SetOfAssemblyTiles& other)const
/*
 Overloaded equal operator
 */
{
    if(this->numberOfAssemblyTiles != other.numberOfAssemblyTiles)
    {
        return false;
    }
    for(int i = 0; i < this->numberOfAssemblyTiles; i++)
    {
        if(!(*(this->listOfAssemblyTiles[i]) == *(other.listOfAssemblyTiles[i])))
        {
            return false;
        }
    }

    return true;
}

bool SetOfAssemblyTiles::contains(const AssemblyTile * const T)const
/*
 Post-Condition: returns true if set already has tile T, and false otherwise
 */
{
    for(QList<AssemblyTile*>::const_iterator it = this->listOfAssemblyTiles.begin(); it != this->listOfAssemblyTiles.end(); ++it)
    {
        if((**it) == (*T))
        {
            return true;
        }
    }

    return false;
}
